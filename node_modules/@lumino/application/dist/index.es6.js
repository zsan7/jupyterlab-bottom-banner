import { CommandRegistry } from '@lumino/commands';
import { PromiseDelegate, PluginRegistry } from '@lumino/coreutils';
import { ContextMenu, Widget } from '@lumino/widgets';

// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2017, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module application
 */
/**
 * A class for creating pluggable applications.
 *
 * @typeParam T - The type of the application shell.
 *
 * #### Notes
 * The `Application` class is useful when creating large, complex
 * UI applications with the ability to be safely extended by third
 * party code via plugins.
 */
class Application {
    /**
     * Construct a new application.
     *
     * @param options - The options for creating the application.
     */
    constructor(options) {
        var _a;
        this._delegate = new PromiseDelegate();
        this._started = false;
        this._bubblingKeydown = false;
        this.pluginRegistry =
            (_a = options.pluginRegistry) !== null && _a !== void 0 ? _a : new PluginRegistry(options);
        this.pluginRegistry.application = this;
        // Initialize the application state.
        this.commands = new CommandRegistry();
        this.contextMenu = new ContextMenu({
            commands: this.commands,
            renderer: options.contextMenuRenderer
        });
        this.shell = options.shell;
    }
    /**
     * The list of all the deferred plugins.
     */
    get deferredPlugins() {
        return this.pluginRegistry.deferredPlugins;
    }
    /**
     * A promise which resolves after the application has started.
     *
     * #### Notes
     * This promise will resolve after the `start()` method is called,
     * when all the bootstrapping and shell mounting work is complete.
     */
    get started() {
        return this._delegate.promise;
    }
    /**
     * Activate all the deferred plugins.
     *
     * @returns A promise which will resolve when each plugin is activated
     * or rejects with an error if one cannot be activated.
     */
    async activateDeferredPlugins() {
        await this.pluginRegistry.activatePlugins('defer');
    }
    /**
     * Activate the plugin with the given ID.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @returns A promise which resolves when the plugin is activated
     *   or rejects with an error if it cannot be activated.
     */
    async activatePlugin(id) {
        return this.pluginRegistry.activatePlugin(id);
    }
    /**
     * Deactivate the plugin and its downstream dependents if and only if the
     * plugin and its dependents all support `deactivate`.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @returns A list of IDs of downstream plugins deactivated with this one.
     */
    async deactivatePlugin(id) {
        return this.pluginRegistry.deactivatePlugin(id);
    }
    /**
     * Deregister a plugin with the application.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @param force - Whether to deregister the plugin even if it is active.
     */
    deregisterPlugin(id, force) {
        this.pluginRegistry.deregisterPlugin(id, force);
    }
    /**
     * Get a plugin description.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @returns The plugin description.
     */
    getPluginDescription(id) {
        return this.pluginRegistry.getPluginDescription(id);
    }
    /**
     * Test whether a plugin is registered with the application.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @returns `true` if the plugin is registered, `false` otherwise.
     */
    hasPlugin(id) {
        return this.pluginRegistry.hasPlugin(id);
    }
    /**
     * Test whether a plugin is activated with the application.
     *
     * @param id - The ID of the plugin of interest.
     *
     * @returns `true` if the plugin is activated, `false` otherwise.
     */
    isPluginActivated(id) {
        return this.pluginRegistry.isPluginActivated(id);
    }
    /**
     * List the IDs of the plugins registered with the application.
     *
     * @returns A new array of the registered plugin IDs.
     */
    listPlugins() {
        return this.pluginRegistry.listPlugins();
    }
    /**
     * Register a plugin with the application.
     *
     * @param plugin - The plugin to register.
     *
     * #### Notes
     * An error will be thrown if a plugin with the same ID is already
     * registered, or if the plugin has a circular dependency.
     *
     * If the plugin provides a service which has already been provided
     * by another plugin, the new service will override the old service.
     */
    registerPlugin(plugin) {
        this.pluginRegistry.registerPlugin(plugin);
    }
    /**
     * Register multiple plugins with the application.
     *
     * @param plugins - The plugins to register.
     *
     * #### Notes
     * This calls `registerPlugin()` for each of the given plugins.
     */
    registerPlugins(plugins) {
        this.pluginRegistry.registerPlugins(plugins);
    }
    /**
     * Resolve an optional service of a given type.
     *
     * @param token - The token for the service type of interest.
     *
     * @returns A promise which resolves to an instance of the requested
     *   service, or `null` if it cannot be resolved.
     *
     * #### Notes
     * Services are singletons. The same instance will be returned each
     * time a given service token is resolved.
     *
     * If the plugin which provides the service has not been activated,
     * resolving the service will automatically activate the plugin.
     *
     * User code will not typically call this method directly. Instead,
     * the optional services for the user's plugins will be resolved
     * automatically when the plugin is activated.
     */
    async resolveOptionalService(token) {
        return this.pluginRegistry.resolveOptionalService(token);
    }
    /**
     * Resolve a required service of a given type.
     *
     * @param token - The token for the service type of interest.
     *
     * @returns A promise which resolves to an instance of the requested
     *   service, or rejects with an error if it cannot be resolved.
     *
     * #### Notes
     * Services are singletons. The same instance will be returned each
     * time a given service token is resolved.
     *
     * If the plugin which provides the service has not been activated,
     * resolving the service will automatically activate the plugin.
     *
     * User code will not typically call this method directly. Instead,
     * the required services for the user's plugins will be resolved
     * automatically when the plugin is activated.
     */
    async resolveRequiredService(token) {
        return this.pluginRegistry.resolveRequiredService(token);
    }
    /**
     * Start the application.
     *
     * @param options - The options for starting the application.
     *
     * @returns A promise which resolves when all bootstrapping work
     *   is complete and the shell is mounted to the DOM.
     *
     * #### Notes
     * This should be called once by the application creator after all
     * initial plugins have been registered.
     *
     * If a plugin fails to the load, the error will be logged and the
     * other valid plugins will continue to be loaded.
     *
     * Bootstrapping the application consists of the following steps:
     * 1. Activate the startup plugins
     * 2. Wait for those plugins to activate
     * 3. Attach the shell widget to the DOM
     * 4. Add the application event listeners
     */
    async start(options = {}) {
        var _a, _b;
        // Return immediately if the application is already started.
        if (this._started) {
            return this._delegate.promise;
        }
        // Mark the application as started;
        this._started = true;
        this._bubblingKeydown = (_a = options.bubblingKeydown) !== null && _a !== void 0 ? _a : false;
        // Parse the host ID for attaching the shell.
        const hostID = (_b = options.hostID) !== null && _b !== void 0 ? _b : '';
        // Wait for the plugins to activate, then finalize startup.
        await this.pluginRegistry.activatePlugins('startUp', options);
        this.attachShell(hostID);
        this.addEventListeners();
        this._delegate.resolve();
    }
    /**
     * Handle the DOM events for the application.
     *
     * @param event - The DOM event sent to the application.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events registered for the application. It
     * should not be called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'resize':
                this.evtResize(event);
                break;
            case 'keydown':
                this.evtKeydown(event);
                break;
            case 'keyup':
                this.evtKeyup(event);
                break;
            case 'contextmenu':
                this.evtContextMenu(event);
                break;
        }
    }
    /**
     * Attach the application shell to the DOM.
     *
     * @param id - The ID of the host node for the shell, or `''`.
     *
     * #### Notes
     * If the ID is not provided, the document body will be the host.
     *
     * A subclass may reimplement this method as needed.
     */
    attachShell(id) {
        Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);
    }
    /**
     * Add the application event listeners.
     *
     * #### Notes
     * The default implementation of this method adds listeners for
     * `'keydown'` and `'resize'` events.
     *
     * A subclass may reimplement this method as needed.
     */
    addEventListeners() {
        document.addEventListener('contextmenu', this);
        document.addEventListener('keydown', this, !this._bubblingKeydown);
        document.addEventListener('keyup', this, !this._bubblingKeydown);
        window.addEventListener('resize', this);
    }
    /**
     * A method invoked on a document `'keydown'` event.
     *
     * #### Notes
     * The default implementation of this method invokes the key down
     * processing method of the application command registry.
     *
     * A subclass may reimplement this method as needed.
     */
    evtKeydown(event) {
        this.commands.processKeydownEvent(event);
    }
    /**
     * A method invoked on a document `'keyup'` event.
     *
     * #### Notes
     * The default implementation of this method invokes the key up
     * processing method of the application command registry.
     *
     * A subclass may reimplement this method as needed.
     */
    evtKeyup(event) {
        this.commands.processKeyupEvent(event);
    }
    /**
     * A method invoked on a document `'contextmenu'` event.
     *
     * #### Notes
     * The default implementation of this method opens the application
     * `contextMenu` at the current mouse position.
     *
     * If the application context menu has no matching content *or* if
     * the shift key is pressed, the default browser context menu will
     * be opened instead.
     *
     * A subclass may reimplement this method as needed.
     */
    evtContextMenu(event) {
        if (event.shiftKey) {
            return;
        }
        if (this.contextMenu.open(event)) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * A method invoked on a window `'resize'` event.
     *
     * #### Notes
     * The default implementation of this method updates the shell.
     *
     * A subclass may reimplement this method as needed.
     */
    evtResize(event) {
        this.shell.update();
    }
}

export { Application };
//# sourceMappingURL=index.es6.js.map
