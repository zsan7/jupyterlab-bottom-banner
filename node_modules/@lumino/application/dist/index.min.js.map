{"version":3,"names":["constructor","options","this","_delegate","PromiseDelegate","_started","_bubblingKeydown","pluginRegistry","_a","PluginRegistry","application","commands","CommandRegistry","contextMenu","ContextMenu","renderer","contextMenuRenderer","shell","deferredPlugins","started","promise","async","activatePlugins","id","activatePlugin","deactivatePlugin","deregisterPlugin","force","getPluginDescription","hasPlugin","isPluginActivated","listPlugins","registerPlugin","plugin","registerPlugins","plugins","token","resolveOptionalService","resolveRequiredService","bubblingKeydown","hostID","_b","attachShell","addEventListeners","resolve","handleEvent","event","type","evtResize","evtKeydown","evtKeyup","evtContextMenu","Widget","attach","document","getElementById","body","addEventListener","window","processKeydownEvent","processKeyupEvent","shiftKey","open","preventDefault","stopPropagation","update"],"sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module application\n */\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport {\n  type IPlugin,\n  PluginRegistry,\n  PromiseDelegate,\n  type Token\n} from '@lumino/coreutils';\n\nimport { ContextMenu, Menu, Widget } from '@lumino/widgets';\n\n// Export IPlugin for API backward compatibility\n/**\n * @deprecated You should import it from @lumino/coreutils.\n */\nexport { type IPlugin };\n\n/**\n * A class for creating pluggable applications.\n *\n * @typeParam T - The type of the application shell.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nexport class Application<T extends Widget = Widget> {\n  /**\n   * Construct a new application.\n   *\n   * @param options - The options for creating the application.\n   */\n  constructor(options: Application.IOptions<T>) {\n    this.pluginRegistry =\n      options.pluginRegistry ?? new PluginRegistry<this>(options);\n    this.pluginRegistry.application = this;\n\n    // Initialize the application state.\n    this.commands = new CommandRegistry();\n    this.contextMenu = new ContextMenu({\n      commands: this.commands,\n      renderer: options.contextMenuRenderer\n    });\n    this.shell = options.shell;\n  }\n\n  /**\n   * The application command registry.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The application context menu.\n   */\n  readonly contextMenu: ContextMenu;\n\n  /**\n   * The application shell widget.\n   *\n   * #### Notes\n   * The shell widget is the root \"container\" widget for the entire\n   * application. It will typically expose an API which allows the\n   * application plugins to insert content in a variety of places.\n   */\n  readonly shell: T;\n\n  /**\n   * The list of all the deferred plugins.\n   */\n  get deferredPlugins(): string[] {\n    return this.pluginRegistry.deferredPlugins;\n  }\n\n  /**\n   * A promise which resolves after the application has started.\n   *\n   * #### Notes\n   * This promise will resolve after the `start()` method is called,\n   * when all the bootstrapping and shell mounting work is complete.\n   */\n  get started(): Promise<void> {\n    return this._delegate.promise;\n  }\n\n  /**\n   * Activate all the deferred plugins.\n   *\n   * @returns A promise which will resolve when each plugin is activated\n   * or rejects with an error if one cannot be activated.\n   */\n  async activateDeferredPlugins(): Promise<void> {\n    await this.pluginRegistry.activatePlugins('defer');\n  }\n\n  /**\n   * Activate the plugin with the given ID.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A promise which resolves when the plugin is activated\n   *   or rejects with an error if it cannot be activated.\n   */\n  async activatePlugin(id: string): Promise<void> {\n    return this.pluginRegistry.activatePlugin(id);\n  }\n\n  /**\n   * Deactivate the plugin and its downstream dependents if and only if the\n   * plugin and its dependents all support `deactivate`.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A list of IDs of downstream plugins deactivated with this one.\n   */\n  async deactivatePlugin(id: string): Promise<string[]> {\n    return this.pluginRegistry.deactivatePlugin(id);\n  }\n\n  /**\n   * Deregister a plugin with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @param force - Whether to deregister the plugin even if it is active.\n   */\n  deregisterPlugin(id: string, force?: boolean): void {\n    this.pluginRegistry.deregisterPlugin(id, force);\n  }\n\n  /**\n   * Get a plugin description.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns The plugin description.\n   */\n  getPluginDescription(id: string): string {\n    return this.pluginRegistry.getPluginDescription(id);\n  }\n\n  /**\n   * Test whether a plugin is registered with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is registered, `false` otherwise.\n   */\n  hasPlugin(id: string): boolean {\n    return this.pluginRegistry.hasPlugin(id);\n  }\n\n  /**\n   * Test whether a plugin is activated with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is activated, `false` otherwise.\n   */\n  isPluginActivated(id: string): boolean {\n    return this.pluginRegistry.isPluginActivated(id);\n  }\n\n  /**\n   * List the IDs of the plugins registered with the application.\n   *\n   * @returns A new array of the registered plugin IDs.\n   */\n  listPlugins(): string[] {\n    return this.pluginRegistry.listPlugins();\n  }\n\n  /**\n   * Register a plugin with the application.\n   *\n   * @param plugin - The plugin to register.\n   *\n   * #### Notes\n   * An error will be thrown if a plugin with the same ID is already\n   * registered, or if the plugin has a circular dependency.\n   *\n   * If the plugin provides a service which has already been provided\n   * by another plugin, the new service will override the old service.\n   */\n  registerPlugin(plugin: IPlugin<this, any>): void {\n    this.pluginRegistry.registerPlugin(plugin);\n  }\n\n  /**\n   * Register multiple plugins with the application.\n   *\n   * @param plugins - The plugins to register.\n   *\n   * #### Notes\n   * This calls `registerPlugin()` for each of the given plugins.\n   */\n  registerPlugins(plugins: IPlugin<this, any>[]): void {\n    this.pluginRegistry.registerPlugins(plugins);\n  }\n\n  /**\n   * Resolve an optional service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or `null` if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the optional services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\n    return this.pluginRegistry.resolveOptionalService<U>(token);\n  }\n\n  /**\n   * Resolve a required service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or rejects with an error if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the required services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveRequiredService<U>(token: Token<U>): Promise<U> {\n    return this.pluginRegistry.resolveRequiredService<U>(token);\n  }\n\n  /**\n   * Start the application.\n   *\n   * @param options - The options for starting the application.\n   *\n   * @returns A promise which resolves when all bootstrapping work\n   *   is complete and the shell is mounted to the DOM.\n   *\n   * #### Notes\n   * This should be called once by the application creator after all\n   * initial plugins have been registered.\n   *\n   * If a plugin fails to the load, the error will be logged and the\n   * other valid plugins will continue to be loaded.\n   *\n   * Bootstrapping the application consists of the following steps:\n   * 1. Activate the startup plugins\n   * 2. Wait for those plugins to activate\n   * 3. Attach the shell widget to the DOM\n   * 4. Add the application event listeners\n   */\n  async start(options: Application.IStartOptions = {}): Promise<void> {\n    // Return immediately if the application is already started.\n    if (this._started) {\n      return this._delegate.promise;\n    }\n\n    // Mark the application as started;\n    this._started = true;\n\n    this._bubblingKeydown = options.bubblingKeydown ?? false;\n\n    // Parse the host ID for attaching the shell.\n    const hostID = options.hostID ?? '';\n\n    // Wait for the plugins to activate, then finalize startup.\n    await this.pluginRegistry.activatePlugins('startUp', options);\n\n    this.attachShell(hostID);\n    this.addEventListeners();\n    this._delegate.resolve();\n  }\n\n  /**\n   * Handle the DOM events for the application.\n   *\n   * @param event - The DOM event sent to the application.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events registered for the application. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'resize':\n        this.evtResize(event);\n        break;\n      case 'keydown':\n        this.evtKeydown(event as KeyboardEvent);\n        break;\n      case 'keyup':\n        this.evtKeyup(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        this.evtContextMenu(event as PointerEvent);\n        break;\n    }\n  }\n\n  /**\n   * Attach the application shell to the DOM.\n   *\n   * @param id - The ID of the host node for the shell, or `''`.\n   *\n   * #### Notes\n   * If the ID is not provided, the document body will be the host.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected attachShell(id: string): void {\n    Widget.attach(\n      this.shell,\n      (id && document.getElementById(id)) || document.body\n    );\n  }\n\n  /**\n   * Add the application event listeners.\n   *\n   * #### Notes\n   * The default implementation of this method adds listeners for\n   * `'keydown'` and `'resize'` events.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected addEventListeners(): void {\n    document.addEventListener('contextmenu', this);\n    document.addEventListener('keydown', this, !this._bubblingKeydown);\n    document.addEventListener('keyup', this, !this._bubblingKeydown);\n    window.addEventListener('resize', this);\n  }\n\n  /**\n   * A method invoked on a document `'keydown'` event.\n   *\n   * #### Notes\n   * The default implementation of this method invokes the key down\n   * processing method of the application command registry.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtKeydown(event: KeyboardEvent): void {\n    this.commands.processKeydownEvent(event);\n  }\n\n  /**\n   * A method invoked on a document `'keyup'` event.\n   *\n   * #### Notes\n   * The default implementation of this method invokes the key up\n   * processing method of the application command registry.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtKeyup(event: KeyboardEvent): void {\n    this.commands.processKeyupEvent(event);\n  }\n\n  /**\n   * A method invoked on a document `'contextmenu'` event.\n   *\n   * #### Notes\n   * The default implementation of this method opens the application\n   * `contextMenu` at the current mouse position.\n   *\n   * If the application context menu has no matching content *or* if\n   * the shift key is pressed, the default browser context menu will\n   * be opened instead.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtContextMenu(event: PointerEvent): void {\n    if (event.shiftKey) {\n      return;\n    }\n    if (this.contextMenu.open(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * A method invoked on a window `'resize'` event.\n   *\n   * #### Notes\n   * The default implementation of this method updates the shell.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtResize(event: Event): void {\n    this.shell.update();\n  }\n\n  /**\n   * Application plugin registry.\n   */\n  protected pluginRegistry: PluginRegistry;\n  private _delegate = new PromiseDelegate<void>();\n  private _started = false;\n  private _bubblingKeydown = false;\n}\n\n/**\n * The namespace for the `Application` class statics.\n */\nexport namespace Application {\n  /**\n   * An options object for creating an application.\n   */\n  export interface IOptions<T extends Widget> extends PluginRegistry.IOptions {\n    /**\n     * The shell widget to use for the application.\n     *\n     * This should be a newly created and initialized widget.\n     *\n     * The application will attach the widget to the DOM.\n     */\n    shell: T;\n\n    /**\n     * A custom renderer for the context menu.\n     */\n    contextMenuRenderer?: Menu.IRenderer;\n\n    /**\n     * Application plugin registry.\n     *\n     * If defined the options related to the plugin registry will\n     * be ignored.\n     */\n    pluginRegistry?: PluginRegistry;\n  }\n\n  /**\n   * An options object for application startup.\n   */\n  export interface IStartOptions {\n    /**\n     * The ID of the DOM node to host the application shell.\n     *\n     * #### Notes\n     * If this is not provided, the document body will be the host.\n     */\n    hostID?: string;\n\n    /**\n     * The plugins to activate on startup.\n     *\n     * #### Notes\n     * These will be *in addition* to any `autoStart` plugins.\n     */\n    startPlugins?: string[];\n\n    /**\n     * The plugins to **not** activate on startup.\n     *\n     * #### Notes\n     * This will override `startPlugins` and any `autoStart` plugins.\n     */\n    ignorePlugins?: string[];\n\n    /**\n     * Whether to capture keydown event at bubbling or capturing (default) phase for\n     * keyboard shortcuts.\n     *\n     * @experimental\n     */\n    bubblingKeydown?: boolean;\n  }\n}\n"],"mappings":"udA+CEA,YAAYC,G,MA6XJC,KAAAC,UAAY,IAAIC,kBAChBF,KAAQG,UAAG,EACXH,KAAgBI,kBAAG,EA9XzBJ,KAAKK,eACmB,QAAtBC,EAAAP,EAAQM,sBAAc,IAAAC,IAAI,IAAIC,iBAAqBR,GACrDC,KAAKK,eAAeG,YAAcR,KAGlCA,KAAKS,SAAW,IAAIC,kBACpBV,KAAKW,YAAc,IAAIC,cAAY,CACjCH,SAAUT,KAAKS,SACfI,SAAUd,EAAQe,sBAEpBd,KAAKe,MAAQhB,EAAQgB,K,CA0BnBC,sBACF,OAAOhB,KAAKK,eAAeW,e,CAUzBC,cACF,OAAOjB,KAAKC,UAAUiB,O,CASxBC,sCACQnB,KAAKK,eAAee,gBAAgB,Q,CAW5CD,qBAAqBE,GACnB,OAAOrB,KAAKK,eAAeiB,eAAeD,E,CAW5CF,uBAAuBE,GACrB,OAAOrB,KAAKK,eAAekB,iBAAiBF,E,CAU9CG,iBAAiBH,EAAYI,GAC3BzB,KAAKK,eAAemB,iBAAiBH,EAAII,E,CAU3CC,qBAAqBL,GACnB,OAAOrB,KAAKK,eAAeqB,qBAAqBL,E,CAUlDM,UAAUN,GACR,OAAOrB,KAAKK,eAAesB,UAAUN,E,CAUvCO,kBAAkBP,GAChB,OAAOrB,KAAKK,eAAeuB,kBAAkBP,E,CAQ/CQ,cACE,OAAO7B,KAAKK,eAAewB,a,CAe7BC,eAAeC,GACb/B,KAAKK,eAAeyB,eAAeC,E,CAWrCC,gBAAgBC,GACdjC,KAAKK,eAAe2B,gBAAgBC,E,CAsBtCd,6BAAgCe,GAC9B,OAAOlC,KAAKK,eAAe8B,uBAA0BD,E,CAsBvDf,6BAAgCe,GAC9B,OAAOlC,KAAKK,eAAe+B,uBAA0BF,E,CAwBvDf,YAAYpB,EAAqC,I,QAE/C,GAAIC,KAAKG,SACP,OAAOH,KAAKC,UAAUiB,QAIxBlB,KAAKG,UAAW,EAEhBH,KAAKI,iBAA8C,QAA3BE,EAAAP,EAAQsC,uBAAmB,IAAA/B,KAGnD,MAAMgC,EAAuB,QAAdC,EAAAxC,EAAQuC,cAAM,IAAAC,IAAI,SAG3BvC,KAAKK,eAAee,gBAAgB,UAAWrB,GAErDC,KAAKwC,YAAYF,GACjBtC,KAAKyC,oBACLzC,KAAKC,UAAUyC,S,CAajBC,YAAYC,GACV,OAAQA,EAAMC,MACZ,IAAK,SACH7C,KAAK8C,UAAUF,GACf,MACF,IAAK,UACH5C,KAAK+C,WAAWH,GAChB,MACF,IAAK,QACH5C,KAAKgD,SAASJ,GACd,MACF,IAAK,cACH5C,KAAKiD,eAAeL,G,CAehBJ,YAAYnB,GACpB6B,SAAOC,OACLnD,KAAKe,MACJM,GAAM+B,SAASC,eAAehC,IAAQ+B,SAASE,K,CAa1Cb,oBACRW,SAASG,iBAAiB,cAAevD,MACzCoD,SAASG,iBAAiB,UAAWvD,MAAOA,KAAKI,kBACjDgD,SAASG,iBAAiB,QAASvD,MAAOA,KAAKI,kBAC/CoD,OAAOD,iBAAiB,SAAUvD,K,CAY1B+C,WAAWH,GACnB5C,KAAKS,SAASgD,oBAAoBb,E,CAY1BI,SAASJ,GACjB5C,KAAKS,SAASiD,kBAAkBd,E,CAgBxBK,eAAeL,GACnBA,EAAMe,UAGN3D,KAAKW,YAAYiD,KAAKhB,KACxBA,EAAMiB,iBACNjB,EAAMkB,kB,CAYAhB,UAAUF,GAClB5C,KAAKe,MAAMgD,Q"}